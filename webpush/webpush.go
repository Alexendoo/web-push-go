/*
Package webpush implements the message encryption required by the Web Push protocol
*/
package webpush

import (
	"crypto/ecdsa"
	"errors"
	"net/http"
	"strconv"
	"time"
)

// Subscription is a User Agent's push message subscription
//
//  - https://www.w3.org/TR/push-api/#dom-pushsubscription
type Subscription struct {
	// The push endpoint URL, unique to the given push subscription
	Endpoint string
	// 16 random bytes generated by the user agent, called auth_secret in the
	// RFC 8291 encryption summary
	Auth []byte
	// The P-256 public key generated by the User Agent
	P256DH *PublicKey
}

// Urgency allows battery powered devices to avoid expending power on less
// important messages by only fetching messages of a certain urgency
type Urgency string

var (
	// UrgencyVeryLow sends notifications to devices that are both connected
	// to power and on Wi-Fi
	UrgencyVeryLow Urgency = "very-low"
	// UrgencyLow includes devices that are on either power or Wi-Fi
	UrgencyLow Urgency = "low"
	// UrgencyNormal includes devices that are not connected to power nor Wi-Fi
	// with acceptable remaining battery life
	UrgencyNormal Urgency = "normal"
	// UrgencyHigh includes devices with low battery power
	UrgencyHigh Urgency = "high"
)

type Options struct {
	SigningKey *ecdsa.PrivateKey
	Urgency    Urgency
	TTL        time.Duration
	Topic      string
}

// New encrypts the message and creates a HTTP request that will submit it to
// the push endpoint
func New(sub *Subscription, message []byte, opts *Options) (*http.Request, error) {
	if sub == nil {
		return nil, errors.New("webpush: Encrypt requires non-nil Subscription")
	}

	if opts == nil {
		opts = &Options{}
	}

	keypair, err := generateKey(p256)
	if err != nil {
		return nil, err
	}

	salt, err := randomBytes(16)
	if err != nil {
		return nil, err
	}

	reader, err := encrypt(sub, keypair, message, salt, opts)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest(http.MethodPost, sub.Endpoint, reader)
	if err != nil {
		return nil, err
	}

	err = setHeaders(req, opts)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}

func setHeaders(req *http.Request, opts *Options) error {
	req.Header.Set("Content-Encoding", "aes128gcm")
	req.Header.Set("TTL", formatTTL(opts.TTL))
	if opts.Urgency != "" {
		req.Header.Set("Urgency", string(opts.Urgency))
	}
	if opts.Topic != "" {
		req.Header.Set("Topic", opts.Topic)
	}
	if opts.SigningKey != nil {
		err := vapidHeader(req, opts.SigningKey)
		if err != nil {
			return err
		}
	}

	return nil
}

func formatTTL(ttl time.Duration) string {
	if ttl <= 0 {
		return "0"
	}

	secs := int64(ttl / time.Second)

	return strconv.FormatInt(secs, 10)
}
